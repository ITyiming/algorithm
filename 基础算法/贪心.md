# 贪心

贪心算法（Greedy Algorithm）是一种求解优化问题的常用方法。它通过每一步选择当前状态下的最佳解决方案，从而希望最终达到全局最优解。贪心算法的思想非常简单，每一步都做出局部最优选择，以期望最终达到全局最优。然而，由于其局部选择的特性，贪心算法并不一定能够求得全局最优解，但在某些问题上却能够快速有效地求解。

下面是贪心算法的一般流程：

1. **建立问题模型**：首先，需要将优化问题抽象成一个数学模型，明确问题的目标和约束条件。

2. **确定贪心策略**：针对问题的特点，确定一种贪心策略，即在每一步选择中如何做出局部最优选择。

3. **构建算法框架**：根据贪心策略，设计算法框架，实现贪心算法的主要逻辑。

4. **验证正确性**：分析算法的正确性，证明贪心策略在每一步选择中都能得到局部最优解，并推导出最终的全局最优解。

5. **实现算法**：基于算法框架，编写代码实现贪心算法。

6. **分析复杂度**：分析算法的时间复杂度和空间复杂度，评估算法的效率。

贪心算法适用于满足以下两个条件的问题：

- **最优子结构性质**：问题的最优解可以通过子问题的最优解推导得到。
- **贪心选择性质**：通过局部最优选择能够获得全局最优解。

贪心算法的优点包括：

- **简单**：贪心算法思想简单，易于理解和实现。
- **高效**：贪心算法通常具有较低的时间复杂度，可以在较短时间内求解问题。

然而，贪心算法也存在一些缺点：

- **不一定得到最优解**：由于贪心选择的局部性质，得到的解可能不是全局最优解。
- **难以证明正确性**：证明贪心算法的正确性通常需要严格的数学推导，有时难以完成。

因此，在使用贪心算法时，需要根据问题的特点和要求进行合理选择，有时需要结合其他算法技巧来求解。

## 月饼最大收益计算问题

月饼是中国人在中秋佳节时吃的一种传统食品，不同地区有许多不同风味的月饼。现给定所有种类月饼的库存量、总售价、以及市场的最大需求量，请你计算可以获得的最大收益是多少。

**注意**：销售时允许取出一部分库存。样例给出的情形是这样的：假如我们有 3 种月饼，其库存量分别为 18、15、10 万吨，总售价分别为 75、72、45 亿元。如果市场的最大需求量只有 20 万吨，那么我们最大收益策略应该是卖出全部 15 万吨第 2 种月饼、以及 5 万吨第 3 种月饼，获得 72 + 45/2 = 94.5（亿元）。

### 输入格式

每个输入包含一个测试用例。每个测试用例先给出一个不超过 1000 的正整数 N 表示月饼的种类数、以及不超过 500（以万吨为单位）的正整数 D 表示市场最大需求量。随后一行给出 N 个正数表示每种月饼的库存量（以万吨为单位）；最后一行给出 N 个正数表示每种月饼的总售价（以亿元为单位）。数字间以空格分隔。

### 输出格式

对每组测试用例，在一行中输出最大收益，以亿元为单位并精确到小数点后 2 位。

### 输入样例

```
3 20
18 15 10
75 72 45
```

### 输出样例

```
94.50
```

### 代码长度限制

16 KB

### 时间限制

150 ms

### 内存限制

64 MB

## 代码示例1

```c++
#include <iostream>
#include <algorithm>
#include <iomanip>
using namespace std;
struct mooncake {
    double store; // 库存量
    double sell; // 总售价
    double price; // 单价
}cake[1010];
bool cmp(mooncake a, mooncake b) { // 按单价从高到低排序
    return a.price > b.price;
}
int main(){
    int n;
    double D;
    cin >> n >> D;
    for(int i = 0; i < n; i++){
        cin >> cake[i].store;
    }
    for(int i = 0; i < n; i++){
        cin >> cake[i].sell;
        cake[i].price = cake[i].sell / cake[i].store;
    }
    sort(cake, cake + n, cmp);
    double ans = 0; // 收益
    for(int i = 0; i < n; i++){
        if(cake[i].store <= D){
            D -= cake[i].store;
            ans += cake[i].sell;
        } else {
            ans += cake[i].price * D;
            break;
        }
    }
    cout << fixed << setprecision(2) << ans << endl;
    return 0;
}
```

```c++
#include <iostream>
#include <vector>
#include <algorithm>
#include <iomanip> // For setprecision

using namespace std;

struct Mooncake {
    double inventory;
    double price;
};

bool compare(Mooncake a, Mooncake b) {
    return a.price / a.inventory > b.price / b.inventory;
}

int main() {
    int N, D;
    cin >> N >> D;

    vector<Mooncake> mooncakes(N);
    for (int i = 0; i < N; ++i) {
        cin >> mooncakes[i].inventory;
    }
    for (int i = 0; i < N; ++i) {
        cin >> mooncakes[i].price;
    }

    sort(mooncakes.begin(), mooncakes.end(), compare);

    double profit = 0.0;
    for (int i = 0; i < N; ++i) {
        if (D >= mooncakes[i].inventory) {
            profit += mooncakes[i].price;
            D -= mooncakes[i].inventory;
        } else {
            profit += D * (mooncakes[i].price / mooncakes[i].inventory);
            break;
        }
    }

    cout << fixed << setprecision(2) << profit << endl;

    return 0;
}

```

`cout << fixed << setprecision(2) << profit << endl;` 是一条 C++ 语句，它的作用是输出变量 `profit` 的值到标准输出，并控制输出格式。

- `fixed` 是一个 I/O 操纵符，用于设置浮点数的输出格式为固定点表示法，即小数点后显示固定位数的数字。默认情况下，浮点数采用科学计数法输出，使用 `fixed` 可以改为固定点表示法。
  
- `setprecision(2)` 是另一个 I/O 操纵符，用于设置浮点数的输出精度，即小数点后的位数。在这里，`setprecision(2)` 将小数点后的位数设置为 2。

- `profit` 是需要输出的变量，表示最终的收益。

- `endl` 是 C++ 中的换行符，它的作用是在输出结束之后插入一个换行符，并刷新输出缓冲区，确保输出立即显示在屏幕上。

综合起来，这条语句的作用是以固定点表示法，保留两位小数的精度，将 `profit` 的值输出到标准输出，并在末尾添加一个换行符。

## 给定数字排序问题

给定数字 0-9 各若干个。你可以以任意顺序排列这些数字，但必须全部使用。目标是使得最后得到的数尽可能小（注意 0 不能做首位）。例如：给定两个 0，两个 1，三个 5，一个 8，我们得到的最小的数就是 10015558。

现给定数字，请编写程序输出能够组成的最小的数。

#### 输入格式：
输入在一行中给出 10 个非负整数，顺序表示我们拥有数字 0、数字 1、……数字 9 的个数。整数间用一个空格分隔。10 个数字的总个数不超过 50，且至少拥有 1 个非 0 的数字。

#### 输出格式：
在一行中输出能够组成的最小的数。

#### 输入样例：
```
2 2 0 0 0 3 0 0 1 0
```

#### 输出样例：
```
10015558
```

## 代码示例2

```c++
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

using namespace std;

int main() {
    vector<int> counts(10);
    // 读取每个数字的数量
    for (int i = 0; i < 10; ++i) {
        cin >> counts[i];
    }

    string result;

    // 找到最小的非零数字
    int nonzero = -1;
    for (int i = 1; i < 10; ++i) {
        if (counts[i] > 0) {
            result += to_string(i);
            counts[i]--;
            nonzero = i;
            break;
        }
    }

    // 添加零
    while (counts[0] > 0) {
        result += "0";
        counts[0]--;
    }

    // 按递增顺序添加剩余的数字
    for (int i = 1; i < 10; ++i) {
        while (counts[i] > 0) {
            result += to_string(i);
            counts[i]--;
        }
    }

    cout << result << endl;

    return 0;
}

```

