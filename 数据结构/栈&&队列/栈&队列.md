# 栈&队列

## 栈（Stack）：

栈是一种后进先出（LIFO，Last In First Out）的数据结构。

#### 示例代码：

```cpp
#include <iostream>
#include <stack>
using namespace std;

int main() {
    stack<int> s;

    // 压栈
    s.push(1);
    s.push(2);
    s.push(3);

    // 弹栈
    while (!s.empty()) {
        cout << s.top() << " "; // 输出栈顶元素
        s.pop(); // 弹出栈顶元素
    }

    return 0;
}
```

#### 主要操作：

- **压栈（Push）：** 将元素添加到栈顶。
- **弹栈（Pop）：** 弹出栈顶元素。
- **获取栈顶元素（Top）：** 返回栈顶元素，但不删除。
- **判断栈空（Empty）：** 判断栈是否为空。
- **获取栈大小（Size）：** 返回栈中元素的个数。

#### 应用场景：

- **函数调用：** 函数的调用过程中，函数的参数、局部变量、返回地址等信息通常保存在栈中。
- **表达式求值：** 中缀表达式转后缀表达式以及后缀表达式的求值过程中使用栈来保存操作符。
- **浏览器的后退功能：** 浏览器的后退功能使用了一个访问历史栈来记录用户访问的页面。

## 队列（Queue）：

队列是一种先进先出（FIFO，First In First Out）的数据结构。

#### 示例代码：

```cpp
#include <iostream>
#include <queue>
using namespace std;

int main() {
    queue<int> q;

    // 入队
    q.push(1);
    q.push(2);
    q.push(3);

    // 出队
    while (!q.empty()) {
        cout << q.front() << " "; // 输出队首元素
        q.pop(); // 出队
    }

    return 0;
}
```

#### 主要操作：

- **入队（Enqueue）：** 将元素添加到队列的末尾。
- **出队（Dequeue）：** 移除并返回队列的第一个元素。
- **获取队头元素（Front）：** 返回队列的第一个元素，但不删除。
- **判断队列空（Empty）：** 判断队列是否为空。
- **获取队列大小（Size）：** 返回队列中元素的个数。

#### 应用场景：

- **任务调度：** 多个任务按照提交顺序依次进入队列，然后依次被执行。
- **缓冲区：** 缓冲区通常使用队列来管理数据的输入和输出。
- **广度优先搜索（BFS）：** 在BFS算法中，通常使用队列来存储待访问的节点。

## 优先队列（Priority Queue）：

优先队列是一种特殊的队列，元素按照优先级顺序进行排列。

#### 示例代码：

```cpp
#include <iostream>
#include <queue>
using namespace std;

int main() {
    priority_queue<int> pq;

    // 插入元素
    pq.push(3);
    pq.push(1);
    pq.push(2);

    // 删除最高优先级元素
    while (!pq.empty()) {
        cout << pq.top() << " "; // 输出当前优先级最高的元素
        pq.pop(); // 删除当前优先级最高的元素
    }

    return 0;
}
```

#### 主要操作：

- **插入元素：** 将元素插入优先队列中，根据优先级进行排序。
- **获取最高优先级元素：** 返回当前优先队列中优先级最高的元素。
- **删除最高优先级元素：** 删除并返回当前优先队列中优先级最高的元素。
- **判断优先队列空：** 判断优先队列是否为空。
- **获取优先队列大小：** 返回优先队列中元素的个数。

#### 应用场景：

- **任务调度：** 任务的执行顺序按照任务的优先级来确定。
- **最小（大）堆排序：** 使用最小（大）堆实现优先队列，进行堆排序。

## 总结：

- 栈适用于需要后进先出的场景，如函数调用栈等。
- 队列适用于需要先进先出的场景，如任务调度等。
- 优先队列用于处理具有优先级的元素，可以确保高优先级元素先被处理。

