# BFS

## 算法

广度优先搜索（BFS）是一种图遍历算法，用于在图或树中从给定的起始节点开始遍历，逐层地访问其相邻节点，直到遍历完所有节点或者找到目标节点。BFS通常使用队列来实现。

### 算法步骤：

1. **选择起始节点：** 选择图或树中的一个起始节点作为开始遍历的节点。

2. **将起始节点加入队列：** 将起始节点加入到一个队列中。

3. **循环直到队列为空：**
   - 从队列中取出一个节点。
   - 访问当前节点，并标记为已访问。
   - 遍历当前节点的所有相邻节点：
     - 如果相邻节点未被访问过，则将其加入队列中，并标记为已访问。

4. **重复步骤3，直到队列为空：** 如果队列为空，则遍历结束。

### 特点和应用：

- **逐层遍历：** BFS以逐层的方式遍历图或树，先访问距离起始节点最近的节点，然后是距离起始节点稍远的节点，以此类推。
- **最短路径：** 由于BFS逐层遍历，因此可以在无权图或树中找到起始节点到目标节点的最短路径。
- **无向图和有向图：** BFS适用于无向图和有向图的遍历，但对于有向图，要注意可能存在环的情况，需要标记已访问节点，避免陷入死循环。
- **解决问题：** BFS常用于解决图的连通性、路径搜索、最短路径等问题，例如迷宫问题、单词变换、社交网络中的连通性等。

### 伪代码：

```assembly
BFS(start):
    初始化队列queue
    将起始节点start加入到队列中
    标记start为已访问
    while 队列queue非空:
        取出队首节点node
        访问节点node
        遍历节点node的所有相邻节点:
            如果相邻节点未被访问过:
                将相邻节点加入队列中
                标记相邻节点为已访问
```

### 示例：

考虑一个简单的图结构：

```lua
      1----2
     /     / \
    3----4   5
```

从节点1开始进行BFS遍历的过程如下：

1. 节点1加入队列。
2. 取出队首节点1，访问1，并将与1相邻的未访问过的节点3加入队列。
3. 取出队首节点3，访问3，并将与3相邻的未访问过的节点4加入队列。
4. 取出队首节点4，访问4。
5. 取出队首节点2，访问2，并将与2相邻的未访问过的节点5加入队列。
6. 取出队首节点5，访问5。
7. 队列为空，遍历结束。

因此，从节点1开始进行BFS遍历的结果为：1 -> 3 -> 2 -> 4 -> 5。

## 题目：

给定一个由0和1组成的矩阵，其中1表示陆地，0表示水域。连通的陆地组成一个连通块。现在需要统计矩阵中连通块的个数。每个连通块可以是上下左右四个方向相邻的陆地。

## 解题思路：

这是一个典型的图遍历问题，可以通过广度优先搜索（BFS）来解决。首先，定义一个结构体表示节点的坐标。然后，定义一个函数judge用于判断某个位置是否合法，即是否在矩阵范围内且未被访问过且为1。接着，定义一个BFS函数用于遍历连通块。在BFS函数中，使用队列存放待访问的节点，并依次从队列中取出节点，然后遍历其上下左右四个方向的相邻节点，如果相邻节点合法，则将其加入队列中，并标记为已访问。在主函数中，遍历整个矩阵，对于每个未被访问过的陆地节点，将其作为起始节点进行BFS遍历，并统计连通块的个数。最后输出连通块的个数即可。

```cpp
#include<iostream>
#include<queue>
using namespace std;

// 定义结构体表示节点的坐标
struct node{
    int x;
    int y;
}Node;

const int maxn = 10010;
int matrix[maxn][maxn]; // 原始矩阵
int m, n; // 矩阵的行数和列数
bool log[maxn][maxn] = {false}; // 记录某个位置是否被访问过的标记数组
int X[4] = {0, 0, 1, -1}; // 方向数组，用于探索上下左右四个方向
int Y[4] = {1, -1, 0, 0 };

// 判断某个位置是否合法，即是否在矩阵范围内且未被访问过且为1
bool judge(int x, int y){
    if(x < 0 || x >= m || y < 0 || y >= n) // 越界判断
        return false;
    if(log[x][y] == true || matrix[x][y] == 0) // 已访问或者为0的位置不合法
        return false;
    return true;
}

// BFS遍历连通块
void BFS(int x, int y){
    queue<node> Q; // 定义队列存放待访问的节点
    Node.x = x;
    Node.y = y;
    Q.push(Node); // 将起始节点加入队列
    node top;
    int nowX, nowY;
    while(!Q.empty()){ // 当队列非空时循环
        top = Q.front(); // 取出队首节点
        Q.pop(); // 弹出队首节点
        for(int i = 0; i < 4; i++){ // 遍历上下左右四个方向
            nowX = top.x + X[i];
            nowY = top.y + Y[i];
            if(judge(nowX, nowY)){ // 判断新位置是否合法
                Node.x = nowX;
                Node.y = nowY;
                Q.push(Node); // 将新位置加入队列
                log[nowX][nowY] = true; // 标记为已访问
            }
        }
    }
}

int main(){
    cin >> m >> n; // 输入矩阵的行数和列数
    for(int i = 0; i < m; i++){
        for(int j = 0; j < n; j++)
            cin >> matrix[i][j]; // 输入矩阵的元素值
    }
    int ans = 0; // 记录连通块的个数
    for(int i = 0; i < m; i++){
        for(int j = 0; j < n; j++){
            if(matrix[i][j] == 1 && log[i][j] == false){ // 如果当前位置为1且未被访问过
                ans++; // 连通块数加1
                BFS(i, j); // 从该位置进行BFS遍历
            }
        }
    }
    cout << ans <<endl; // 输出连通块的个数
    return 0;
}
```

